package alwaysontime2;

import java.util.ArrayList;
import java.util.Random;

public class MCTS {
    int level, iteration, ALPHA, N, capacity;
    double policy[][][], globalPolicy[][];
    Graph deliveryGraph;

    public MCTS(Graph deliveryGraph, int capacity) {
        this.deliveryGraph = deliveryGraph;
        this.capacity = capacity;
        N = deliveryGraph.size;
        level = 3;
        iteration = 100;
        ALPHA = 1;
        policy = new double[level][N][N];
        globalPolicy = new double[N][N];
    }
    
    public MCTS(Graph deliveryGraph, int capacity, int level, int iteration) {
        this.deliveryGraph = deliveryGraph;
        this.capacity = capacity;
        this.level = level;
        this.iteration = iteration;
        N = deliveryGraph.size;
        ALPHA = 1;
        policy = new double[level][N][N];
        globalPolicy = new double[N][N];
    }

    public double getCost(ArrayList<Vertex> route) {
        double totalCost = 0;
        for (int i = 0; i < route.size() - 1; i++) {
            totalCost += deliveryGraph.calculateEdgeWeight(route.get(i).vertexInfo, route.get(i + 1).vertexInfo);
        }
        return totalCost;
    }
    
    public void printMCTS(){
        System.out.println("MCTS simulation");
        ArrayList<ArrayList<Vertex>> vehicles = SearchMCTS(level-1,iteration);
        double tourCost = 0;
        for(ArrayList<Vertex> i : vehicles){ 
            tourCost += getCost(i);
        }
        System.out.println("Tour Cost: "+ tourCost);
        System.out.println(vehicles.size());
        for (ArrayList<Vertex> i : vehicles) {
            System.out.println(i);
        }
    } 
    
    public ArrayList<ArrayList<Vertex>> SearchMCTS(int level, int iteration){
        ArrayList<ArrayList<Vertex>> bestTour = new ArrayList<>();
        double bestTourCost = Double.MAX_VALUE;
        if(level == 0){
            return rollout();
        }
        else{
            policy[level] = globalPolicy;
            for (int i = 0; i < iteration; i++) {
                ArrayList<ArrayList<Vertex>> newTour = SearchMCTS(level-1,iteration);
                double newTourCost = 0;
                for (ArrayList<Vertex> j : newTour) {
                    newTourCost += getCost(j);
                }
                if(newTourCost < bestTourCost){
                    bestTour.clear();
                    for(ArrayList<Vertex> k : newTour){
                        bestTour.add(k);
                    }
                    bestTourCost = newTourCost;
                    adapt(bestTour, level);
                }
            for(Vertex j : (ArrayList<Vertex>)deliveryGraph.getAllVertex()){
                j.setVisited(false);
            }
//                if(processing_time exceed time limit) return bestTour;
            }
            globalPolicy = policy[level];
        }
        return bestTour;
    }
    
    public void adapt(ArrayList<ArrayList<Vertex>> tour, int level){
        ArrayList<Vertex> allStops = deliveryGraph.getAllVertex();
        for (int i = 0; i < tour.size(); i++) {
            ArrayList<Vertex> stops = tour.get(i);
            for (int j = 0; j < stops.size(); j++){
                Vertex stop = stops.get(j);
                Vertex nextStop = stops.get(0);
                if(j != stops.size()-1)
                    nextStop = stops.get(j+1);
                policy[level][stop.getID()][nextStop.getID()] += ALPHA;
                double z = 0;
                for(Vertex k : allStops){ 
                    if(k.equals(stop)) continue;
                    if(!k.isVisited()) z += Math.exp(globalPolicy[stop.getID()][k.getID()]);
                }
                for(Vertex k : allStops){
                    if(k.equals(stop)) continue;
                    if(!k.isVisited()) policy[level][stop.getID()][k.getID()] -= ALPHA * (Math.exp(globalPolicy[stop.getID()][k.getID()])/z);
                }
                stop.setVisited(true);
            }
        }
    }
    
    public ArrayList<ArrayList<Vertex>> rollout(){
        ArrayList<ArrayList<Vertex>> newTour = new ArrayList<>();
        ArrayList<Vertex> start = new ArrayList();
        start.add(deliveryGraph.head);
        newTour.add(start);
        ArrayList<Vertex> allStops = deliveryGraph.getAllVertex();
        ArrayList<Boolean> checked = new ArrayList<>();
        for (int i = 0; i < allStops.size(); i++) {
            checked.add(false);
        }
        while(true){
            Vertex currentStop = newTour.get(newTour.size()-1).get(newTour.get(newTour.size()-1).size()-1);
            ArrayList<Vertex> possible_successors = new ArrayList<>();
            for (int i = 0; i < allStops.size(); i++) {
                if(allStops.get(i).equals(currentStop))continue;
                if(!allStops.get(i).isVisited()&&!checked.get(i))possible_successors.add(allStops.get(i));
            }
            if(possible_successors.isEmpty()){
                if(!currentStop.equals(deliveryGraph.head)) newTour.get(newTour.size()-1).add(deliveryGraph.head);
                boolean allVisited = true;
                for(Vertex i : allStops){
                    if(!i.isVisited()) allVisited = false;
                }
                if(allVisited) break;
                ArrayList<Vertex> startAgain = new ArrayList();
                startAgain.add(deliveryGraph.head);
                newTour.add(startAgain);
                for(int i = 0; i < checked.size();i++)
                    checked.set(i,false);
                continue;
            }
            Vertex nextStop = select_next_move(currentStop, possible_successors);
            ArrayList<Vertex> lastVehicle = newTour.get(newTour.size()-1);
            int maximumCapacity = 0;
            for (Vertex i : lastVehicle) {
                maximumCapacity += i.getCapacity();
            }
            if((maximumCapacity+nextStop.capacity) <= capacity){
                lastVehicle.add(nextStop);
                nextStop.setVisited(true);
            }
            else{
                checked.set(allStops.indexOf(nextStop),true);
            }
        }
        return newTour;
    }
    
    public Vertex select_next_move(Vertex currentStop, ArrayList<Vertex> possible_successors){
        double[] probability = new double[possible_successors.size()];
        double sum = 0;
        for (int i = 0; i < possible_successors.size(); i++) {
            probability[i] = Math.exp(globalPolicy[currentStop.getID()][possible_successors.get(i).getID()]);
            sum += probability[i];
        }
        double mrand = new Random().nextDouble() * sum;
        int i = 0;
        sum = probability[0];
        while(sum < mrand){
            sum += probability[++i];
        }
        return possible_successors.get(i);
    } 
}
